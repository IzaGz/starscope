#!/usr/bin/env ruby

lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'readline'
require 'starscope'

options = {:auto => true, :progress => true, :manual_write => true}
DEFAULT_DB=".starscope.db"

# Options Parsing
OptionParser.new do |opts|
  opts.banner = <<END
Usage: starscope [options] [PATHS]

If you don't pass any of -n, -r, -w or PATHS, default behaviour is to recurse
in the current directory and build or update the database `#{DEFAULT_DB}`.

Query scopes must be specified with `::`, for example -q calls,File::mtime.
END

  opts.separator "\nQueries"
  opts.on("-d", "--dump [TABLE]", "Dumps the DB or specified table to stdout") do |tbl|
    options[:dump] = tbl || true
  end
  opts.on("-l", "--line-mode", "Starts line-oriented interface") do
    options[:linemode] = true
  end
  opts.on("-q", "--query TABLE,QUERY", "Looks up QUERY in TABLE") do |query|
    options[:query] = query
  end
  opts.on("-s", "--summary", "Print a database summary to stdout") do
    options[:summary] = true
  end

  opts.separator "\nDatabase Management"
  opts.on("-e", "--export FORMAT[,PATH]", "Export in FORMAT to PATH, (see EXPORTING)") do |export|
    options[:export] = export
  end
  opts.on("-n", "--no-auto", "Don't automatically update/create the DB") do
    options[:auto] = false
  end
  opts.on("-r", "--read-db PATH", "Reads the DB from PATH instead of default") do |path|
    options[:read] = path
  end
  opts.on("-w", "--write-db PATH", "Writes the DB to PATH instead of default") do |path|
    options[:write] = path
  end
  opts.on("-x", "--exclude PATTERN", "Skip files matching PATTERN") do |pattern|
    options[:exclude] ||= []
    options[:exclude] << pattern
  end

  opts.separator "\nMisc"
  opts.on("-v", "--version", "Print the version number") do
    puts StarScope::VERSION
    exit
  end
  opts.on("--no-progress", "Don't show progress-bar when updating DB") do
    options[:progress] = false
  end

  opts.separator <<END
\nEXPORTING
    At the moment two export formats are supported: 'ctags' and 'cscope'. If
    you don't specify a path, the output is written to the files 'tags' (for
    ctags) or 'cscope.out' (for cscope) in the current directory.
END

end.parse!

def print_summary(db)
  db.summary.each do |name, count|
    printf("%-8s %5d records\n", name, count)
  end
end

def run_query(db, table, value)
  if not value
    $stderr.puts "Invalid input - no query found."
    return false
  end
  results = db.query(table.to_sym, value)
  if results
    puts results.map {|val| StarScope::Datum.to_s(val)}
  else
    puts "No results found."
  end
  return true
rescue StarScope::DB::NoTableError
  $stderr.puts "Table '#{table}' doesn't exist."
  return false
end

def dump(db, table)
  if table
    db.dump_table(table.to_sym)
  else
    db.dump_all
  end
  return true
rescue StarScope::DB::NoTableError
  $stderr.puts "Table '#{table}' doesn't exist."
  return false
end

db = StarScope::DB.new(options[:progress])

# user passed neither -n nor -w flags
if options[:auto] and not options[:write]
  options[:write] = DEFAULT_DB
  options[:manual_write] = false
end

if File.exists?(DEFAULT_DB) and not options[:read]
  options[:read] = DEFAULT_DB
end

if options[:read]
  new_data = db.load(options[:read])
end

if not ARGV.empty?
  db.add_paths(ARGV)
  new_data = true
elsif not options[:read]
  # ARGV is empty (no paths specified) and options[:read] is nil (no specific DB
  # file specified) so build a new db defaulting to the current directory
  db.add_paths(['.'])
  new_data = true
end

if options[:exclude]
  db.exclude(options[:exclude])
end

new_data ||= db.update if options[:read] and options[:auto]

# write if we have somewhere to write to, and either:
# - we have new data to save OR
# - we have an explicitly requested write to a specific path
db.save(options[:write]) if options[:write] and (new_data or options[:manual_write])

if options[:export]
  format, path = options[:export].split(',', 2)
  case format
  when 'ctags'
    db.export_ctags(path || 'tags')
  when 'cscope'
    db.export_cscope(path || 'cscope.out')
  else
    puts "Unrecognized export format"
  end
end

if options[:query]
  table, query = options[:query].split(',', 2)
  run_query(db, table, query)
end

print_summary(db) if options[:summary]

if options[:dump]
  if options[:dump].is_a? String
    dump(db, options[:dump])
  else
    dump(db, nil)
  end
end

def linemode_help
  <<END
Input can be a query of the form 'TABLE QUERY' or a special command starting
with a '!'. Recognized special commands are:
  !dump [TABLE]
  !summary
  !update

  !help
  !version
  !quit
END
end

if options[:linemode]
  puts "Run your query as 'TABLE QUERY' or run '!help' for more information."
  while input = Readline.readline("> ", true)
    cmd, param = input.split(' ', 2)
    if cmd[0] == '!'
      case cmd[1..-1]
      when "dump"
        dump(db, param)
      when "summary"
        print_summary(db)
      when "update"
        changed = db.update
        db.save(options[:write]) if options[:write] and changed
      when "help"
        puts linemode_help
      when "version"
        puts StarScope::VERSION
      when "quit"
        exit
      else
        puts "Unknown command: '#{input}', try '!help'."
      end
    else
      success = run_query(db, cmd, param)
      puts "Try '!help'." unless success
    end
  end
end
