#!/usr/bin/env ruby

lib = File.expand_path('../../lib', __FILE__)
$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)

require 'optparse'
require 'readline'
require 'starscope'

DEFAULT_DB=".starscope.db"

options = {:show_progress => true,
           :read => true,
           :write => true,
           :update => true,
           :verbose => false,
           :db => DEFAULT_DB
}

# Options Parsing
OptionParser.new do |opts|
  opts.banner = <<END
Usage: starscope [options] [PATHS]

The default database is `#{DEFAULT_DB}` if you don't specify one with -f.
The default behaviour is to read the database, update it, and write it back out.
If no database exists and no PATHS are specified, StarScope builds a new
database by recursing in the current directory.

Scoped queries must use `::` as the scope separator, even for languages which
have their own scope syntax.
END

  opts.separator "\nQueries"
  opts.on("-d", "--dump [TABLE]", "Dumps the DB or specified table to stdout") do |tbl|
    options[:dump] = tbl || true
  end
  opts.on("-l", "--line-mode", "Starts line-oriented interface") do
    options[:linemode] = true
  end
  opts.on("-q", "--query TABLE,QUERY", "Looks up QUERY in TABLE") do |query|
    options[:query] = query
  end
  opts.on("-s", "--summary", "Print a database summary to stdout") do
    options[:summary] = true
  end

  opts.separator "\nDatabase Management"
  opts.on("-e", "--export FORMAT[,PATH]", "Export in FORMAT to PATH, (see EXPORTING)") do |export|
    options[:export] = export
  end
  opts.on("-f", "--file FILE", "Use FILE instead of `#{DEFAULT_DB}`") do |path|
    options[:db] = path
  end
  opts.on("-x", "--exclude PATTERN", "Skip files matching PATTERN") do |pattern|
    options[:exclude] ||= []
    options[:exclude] << pattern
  end
  opts.on("--no-read", "Don't read the DB from a file") do
    options[:read] = false
  end
  opts.on("--no-write", "Don't write the DB to a file") do
    options[:write] = false
  end
  opts.on("--no-update", "Don't update the DB") do
    options[:update] = false
  end

  opts.separator "\nMisc"
  opts.on("-v", "--version", "Print the version number") do
    puts StarScope::VERSION
    exit
  end
  opts.on("--verbose", "Print extra details") do
    options[:verbose] = true
  end
  opts.on("--no-progress", "Don't show progress-bar when updating DB") do
    options[:show_progress] = false
  end

  opts.separator <<END
\nEXPORTING
    At the moment two export formats are supported: 'ctags' and 'cscope'. If
    you don't specify a path, the output is written to the files 'tags' (for
    ctags) or 'cscope.out' (for cscope) in the current directory.
END

end.parse!

def print_summary(db)
  db.summary.each do |name, count|
    printf("%-8s %5d records\n", name, count)
  end
end

def run_query(db, table, value)
  if not value
    $stderr.puts "Invalid input - no query found."
    return false
  end
  results = db.query(table.to_sym, value)
  if results
    puts results.map {|val| StarScope::Datum.to_s(val)}
  else
    puts "No results found."
  end
  return true
rescue StarScope::DB::NoTableError
  $stderr.puts "Table '#{table}' doesn't exist."
  return false
end

def dump(db, table)
  if table.nil?
    db.dump_all
  elsif table.start_with?('_')
    db.dump_meta(table[1..-1].to_sym)
  else
    db.dump_table(table.to_sym)
  end
  return true
rescue StarScope::DB::NoTableError
  $stderr.puts "Table '#{table}' doesn't exist."
  return false
end

db = StarScope::DB.new(options[:show_progress], options[:verbose])

db_exists = File.exists?(options[:db])

if options[:read] and db_exists
  new_data = db.load(options[:db])
else
  # no need to run an update if we didn't read any old data
  options[:update] = false
end

if options[:exclude]
  db.add_excludes(options[:exclude])
  new_data = true
end

if not ARGV.empty?
  # paths specified, add them
  db.add_paths(ARGV)
  new_data = true
elsif not db_exists
  # no paths were specified and the database did not exist; default to building
  # a new DB in the current directory
  db.add_paths(['.'])
  new_data = true
end

updated = db.update() if options[:update]
new_data ||= updated

db.save(options[:db]) if options[:write] and (new_data or not db_exists)

if options[:export]
  format, path = options[:export].split(',', 2)
  case format
  when 'ctags'
    db.export_ctags(path || 'tags')
  when 'cscope'
    db.export_cscope(path || 'cscope.out')
  else
    puts "Unrecognized export format"
  end
end

if options[:query]
  table, query = options[:query].split(',', 2)
  run_query(db, table, query)
end

print_summary(db) if options[:summary]

if options[:dump]
  if options[:dump].is_a? String
    dump(db, options[:dump])
  else
    dump(db, nil)
  end
end

def linemode_help
  <<END
Input can be a query of the form 'TABLE QUERY' or a special command starting
with a '!'. Recognized special commands are:
  !dump [TABLE]
  !summary
  !update

  !help
  !version
  !quit
END
end

if options[:linemode]
  puts "Run your query as 'TABLE QUERY' or run '!help' for more information."
  while input = Readline.readline("> ", true)
    cmd, param = input.split(' ', 2)
    if cmd[0] == '!'
      case cmd[1..-1]
      when "dump"
        dump(db, param)
      when "summary"
        print_summary(db)
      when "update"
        changed = db.update
        db.save(options[:write]) if options[:write] and changed
      when "help"
        puts linemode_help
      when "version"
        puts StarScope::VERSION
      when "quit"
        exit
      else
        puts "Unknown command: '#{input}', try '!help'."
      end
    else
      success = run_query(db, cmd, param)
      puts "Try '!help'." unless success
    end
  end
end
